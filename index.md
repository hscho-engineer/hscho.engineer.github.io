# 하드코어 시스템 부검 리포트

---
title: "[C++] 3차원 상태 공간 탐색(BFS)의 메모리 통제 및 최적화 리포트"
date: 2026-02-24
tags: [C++, Algorithm, BFS, Memory Optimization, Troubleshooting]
---

## 1. 아키텍처 설계 (System Architecture)
단순한 2차원 배열의 미로 찾기가 아니라, '말의 움직임(K번)'이라는 추가적인 상태(State)가 부여된 복합 BFS 문제(백준 1600)를 해결하기 위한 로직을 설계했다. 
동일한 좌표라도 '말의 능력을 몇 번 남기고 도착했느냐'에 따라 분기가 완전히 달라지므로, 이를 2차원이 아닌 **3차원 상태 공간(State Space)**으로 확장하여 메모리에 할당해야 했다.

## 2. Core Logic 1: 구조체(Struct)를 통한 상태 캡슐화
C++의 `std::pair`를 중첩하여 `pair<pair<int,int>, pair<int,int>>` 형태로 큐(Queue)에 데이터를 삽입하는 것은 가독성을 파괴하고 캐시 히트율을 떨어뜨리는 안티 패턴(Anti-pattern)이다.
이를 방어하기 위해 4개의 상태값(X좌표, Y좌표, 남은 능력 K, 누적 거리 Dist)을 묶는 `Node` 구조체를 직접 정의하여 메모리를 캡슐화(Encapsulation)했다.

```cpp
struct Node {
    int x;
    int y;
    int k;
    int dist;
};
이러한 설계는 큐에 데이터를 PUSH/POP 할 때의 오버헤드를 줄이고, 로직의 직관성을 극대화한다.3. Core Logic 2: 시간-공간 복잡도 트레이드오프 (Trade-off)방문 여부를 단순히 visited[x][y]로 처리하면 큐에 중복된 상태가 쌓여 메모리 초과(OOM)나 시간 초과가 발생한다.따라서 시간 복잡도($O(V+E)$)를 최적화하기 위해, 약 5MB의 메모리 공간을 기꺼이 할당하여 int visited[201][201][31] 형태의 3차원 배열을 구축했다. 제한된 리소스 안에서 실행 속도를 확보하기 위한 의도적인 공간(Space)의 희생이다.4. Troubleshooting: 치명적인 런타임 에러 방어 로직개발 과정에서 아찔한 경계값 오류(Off-by-one Error)가 존재했다.버그 발생 포인트: if(nx < 0 || nx > h || ny < 0 || ny > w) 조건식에서, 배열의 인덱스는 0부터 시작하므로 nx >= h가 되어야 정상이다. 만약 높이가 200일 때 nx가 200이 되면 조건문을 통과해 버려 arr[200][ny]를 참조하는 Out of Bounds (세그멘테이션 폴트)가 발생할 위험이 있었다.방어막 (Fail-safe) 작동: 그러나 main 함수 초입에 작성한 아래의 초기화 로직이 시스템 다운을 막아냈다.C++fill(&arr[0][0], &arr[0][0] + 201 * 201, -1);
배열 전체를 -1로 덮어씌워 둔 덕분에, 범위를 초과한 인덱스를 참조하더라도 즉시 if(arr[nx][ny] != 0) 조건에 걸려 안전하게 continue로 루프를 넘길 수 있었다. 무의식적으로 메모리 영역을 명확히 초기화해 두는 로우 레벨 제어 습관이, 치명적인 런타임 에러를 완벽하게 방어해 낸 흥미로운 디버깅 로그다.
---

이 글은 단순한 문제 풀이가 아니라, "나는 메모리가 어떻게 할당되고, 왜 에러가 나지 않았는지 정확히 통제하고 있다"
