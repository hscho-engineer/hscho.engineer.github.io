## [C++ 딥다이브] 트리의 물리적 메모리 해부: Pointer Chasing과 OS Call Stack의 붕괴
알고리즘에서 '트리(Tree)'를 단순히 동그라미와 선으로 이루어진 수학적 자료구조로 접근하는 것은 시스템 엔지니어링 관점에서 끔찍한 직무 유기다. 트리는 결국 하드웨어의 메모리 위에 배치되는 바이트(Byte)의 덩어리일 뿐이며, 어떻게 탐색하느냐에 따라 운영체제의 스택(Stack)을 터뜨릴 수도, CPU 캐시(Cache)를 무용지물로 만들 수도 있다.

오늘 백준 11725번(트리의 부모 찾기)과 1991번(트리 순회)을 접근하며, 트리를 메모리 레벨에서 제어하는 아키텍처를 정리한다.

## 1. 힙(Heap) 동적 할당의 비극과 캐시 프렌들리(Cache-friendly) 레이아웃
일반적인 교재에서는 트리를 구현할 때 new Node()를 사용하여 힙 영역에 메모리를 동적 할당한다. 하지만 초고트래픽/로우 레벨 백엔드 환경에서 이 방식은 시스템 성능을 박살 낸다. 노드들이 힙 메모리 사방에 파편화되어 할당되기 때문에, 순회할 때마다 CPU가 주소를 찾아 점프하는 '포인터 추적(Pointer Chasing)' 현상이 발생하고, 이는 극단적인 L1/L2 캐시 미스(Cache Miss)를 유발한다.

이를 하드웨어적으로 방어하기 위해 동적 할당을 완전히 배제하고, 연속된 메모리 블록(배열)을 사용하여 CPU의 프리패치(Prefetch)를 극한으로 끌어올리는 구조로 뼈대를 세웠다.

```cpp
// 1. 인접 리스트 방식 (vector 배열)
vector<int> adj[100005];

// 2. 병렬 배열(Parallel Array) 방식
int lcArr[30];
int rcArr[30];
```
배열 안에 연속적으로 박혀있는 자식 노드 번호들을 읽을 때, CPU는 64바이트 캐시 라인(Cache Line) 단위로 뭉텅이로 L1 데이터 캐시에 퍼 올린다. 압도적인 속도는 논리가 아니라 물리적 메모리 레이아웃에서 나온다.

## 2. 가비지-프리(Garbage-free) BFS 아키텍처
일반적인 그래프 탐색에서는 방문 여부를 체크하는 vis[100005] 배열이 필수적이다. 하지만 '사이클이 없는 연결 그래프'라는 트리의 본질을 꿰뚫으면, 400KB의 메모리조차 낭비할 필요가 없다.

"어떤 노드와 연결된 정점 중, 나의 부모 노드만 아니라면 무조건 처음 방문하는 자식 노드다."

```cpp
int pa[100005]; // 부모노드를 저장하는 배열

void bfs(int root) {
    queue<int> q;
    q.push(root);
    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (int i : adj[cur]) {
            if (pa[cur] == i) continue; // 부모로 거슬러 올라가는 역주행만 하드웨어적으로 차단
            pa[i] = cur; 
            q.push(i);
        }
    }
}
```
vis 배열의 할당 자체를 없애버린 완벽한 가비지-프리 로직이다. BFS는 queue를 사용하므로 OS 스택(Call Stack) 대신 광활한 힙(Heap) 영역을 수평적으로 사용하여 안전하게 순회를 마친다.

## 3. DFS 재귀의 폭주와 Call Stack의 붕괴 (Segmentation Fault)
가장 우아하고 짧은 코드로 트리를 깊게 파고드는 재귀 DFS. 하지만 이 우아함의 이면에서는 리눅스 커널 스택의 큰 위험성을 내포하고 있다.

어셈블리 레벨에서 call 명령어가 실행될 때마다 OS는 스택 영역에 Return Address, 매개변수, 레지스터 백업 등을 포함해 약 32~48바이트의 스택 프레임(Stack Frame)을 차곡차곡 쌓는다.
만약 정점이 10만 개인 트리가 일자로 늘어선 '편향 트리(Skewed Tree)'라면 어떻게 될까? dfs()가 10만 번 연속으로 호출되며 약 3.2MB의 스택 프레임이 팽창한다. 만약 노드가 수십만 개 단위로 넘어간다면, 리눅스 커널의 기본 스택 제한(보통 8MB)을 박살 내고 **SIGSEGV (Segmentation Fault)**를 내뿜으며 서버가 데드락에 빠져 즉사하게 된다.

## 4. Stack Overflow의 회피 기동: Heap 영역으로의 이전
시스템 스택 붕괴를 막기 위해, 재귀를 버리고 C++ STL stack (내부적으로 Heap 할당)을 사용하여 LIFO 자료구조를 수동으로 제어한다.

```cpp
void dfs2(int x){
    stack<int> s;
    s.push(x);
    while(!s.empty()){
        int cur = s.top(); s.pop();
        for(int i : adj[cur]){
            if(pa[cur] == i) continue;
            pa[i] = cur;
            s.push(i);
        }
    }
}
```
협소한 8MB짜리 Call Stack의 제약을 벗어나, 수 GB의 힙 영역으로 저장 메모리 공간을 옮겼다.
다만 반복문 기반의 DFS는 스택에서 곧바로 pop을 해버리기 때문에 자식의 처리가 끝날 때까지 부모를 대기시키는 후위 순회(Post-order) 구현이 복잡해진다는 치명적 한계(Trade-off)가 존재한다. 향후 전개될 트리 DP(Tree DP)에서는 이 한계점을 돌파하기 위해 다시 커널 스택의 대기 특성(재귀)을 전략적으로 꺼내 들어야 할 것이다.
