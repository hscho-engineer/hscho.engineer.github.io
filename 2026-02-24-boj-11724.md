---
title: "[C++] 백준 11724 - 연결 요소의 개수: 인접 행렬 vs 인접 리스트 메모리 최적화"
date: 2026-02-24
tags: [C++, Algorithm, Graph, BFS, Memory Optimization]
---
## 1. 문제의 본질 (System Abstraction)
주어진 그래프 공간에서 서로 연결되지 않고 고립된 서브 네트워크(Connected Component)의 개수를 카운팅하는 문제다. 
운영체제의 가비지 컬렉터(GC)가 도달 가능한(Reachable) 메모리 블록을 마킹하는 것과 동일한 로직으로, 전체 정점을 순회하며 방문하지 않은 노드를 기점으로 BFS/DFS 프로세스를 새로 할당해야 한다.

## 2. Core Logic: 자료구조의 선택 (Adjacency List)
정점(V)의 개수가 최대 1,000개, 간선(E)이 존재한다. 
초보자들처럼 연결 상태를 확인하기 위해 `int arr[1001][1001]` 같은 2차원 배열(인접 행렬)을 선언할 경우, $1,000 \times 1,000 = 1,000,000$개의 메모리 공간을 강제 할당해야 하며, 탐색 시에도 무의미한 0(연결 안 됨)을 확인하느라 $O(V^2)$의 연산 비용이 낭비된다.

이를 방어하기 위해 **인접 리스트(`vector<int> vec[1001]`)** 아키텍처를 채택했다.
실제로 간선이 존재하는 타겟 노드의 주소만 힙(Heap) 영역에 동적으로 PUSH 하여 메모리 파편화를 막고, 탐색 시간 복잡도를 $O(V+E)$로 극단적으로 압축했다.

## 3. C++ 하드코어 구현체 (Runtime Code)
모던 C++의 Range-based for loop를 적용하여, 컨테이너의 사이즈를 매번 계산하는 오버헤드를 제거하고 이터레이터(Iterator)를 통해 직관적으로 다음 포인터를 참조하도록 컴파일했다.
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> vec[1001];
int vis[1001];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    
    // 간선 데이터 적재 (Undirected Graph)
    while(m--) {
        int u, v;
        cin >> u >> v;
        vec[u].push_back(v);
        vec[v].push_back(u);
    }

    int num = 0;
    
    // 전체 노드 스케줄링 및 독립 네트워크 탐색
    for(int i = 1; i <= n; i++) {
        if(vis[i]) continue; // 이미 처리된 프로세스는 Drop
        
        num++;
        queue<int> q;
        q.push(i);
        vis[i] = 1;
        
        while(!q.empty()) {
            int cur = q.front();
            q.pop();
            // Range-based for loop를 통한 포인터 직접 참조
            for(auto it : vec[cur]) {
                if(vis[it]) continue;
                q.push(it);
                vis[it] = 1;
            }
        }
    }

    cout << num;
    return 0;
}
```
